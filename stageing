"""
Merge leftover staging tables into main table
- Finds all staging tables matching pattern
- Merges in batches using UNION ALL (fast)
- Falls back to one-by-one if batch fails (TEMP issue)
- Optionally rebuilds indexes after merge
- Drops staging tables after merge

BATCH MERGE ANALYSIS:
- 10 tables × 1.2M rows = 12M rows per batch
- 12M rows × ~200 bytes = ~2.4 GB per batch
- With 128GB TEMP, this is very safe (uses <2% of TEMP)
- Oracle handles UNION ALL efficiently - no sorting needed
- INSERT APPEND bypasses buffer cache = fast direct path
"""

import sys
import gc
import oracledb
from datetime import datetime

# Database connection details
SCHEMA = "placeholder"
DB_USER = SCHEMA
DB_PASSWORD = "placeholder"
DB_HOST = "placeholder"
DB_PORT = "placeholder"
DB_SID = "placeholder"

# Oracle Instant Client path
ORACLE_CLIENT_PATH = r"D:\Homeware\instantclient_23_0"

def init_oracle_client():
    try:
        oracledb.init_oracle_client(lib_dir=ORACLE_CLIENT_PATH)
        print("Oracle thick mode initialized")
    except oracledb.ProgrammingError:
        pass
    except Exception as e:
        print(f"ERROR: {e}")
        sys.exit(1)

def get_connection():
    dsn = oracledb.makedsn(DB_HOST, DB_PORT, sid=DB_SID)
    return oracledb.connect(f"{DB_USER}/{DB_PASSWORD}@{dsn}")

def find_staging_tables(table_name):
    """Find all staging tables for a given table"""
    conn = get_connection()
    cursor = conn.cursor()
    
    # Find tables matching pattern TABLE_STG*
    cursor.execute("""
        SELECT table_name 
        FROM all_tables 
        WHERE owner = :1 
        AND table_name LIKE :2
        ORDER BY table_name
    """, [SCHEMA.upper(), f"{table_name.upper()}_STG%"])
    
    tables = [row[0] for row in cursor.fetchall()]
    cursor.close()
    conn.close()
    return tables

def disable_indexes(table_name):
    """Disable (make unusable) non-unique indexes for faster loading"""
    print(f"\nDisabling non-unique indexes on {table_name}...")
    
    conn = get_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT index_name FROM all_indexes 
        WHERE table_name = :1 AND owner = :2 
        AND uniqueness = 'NONUNIQUE'
        AND index_type != 'LOB'
    """, [table_name.upper(), SCHEMA.upper()])
    
    indexes = [row[0] for row in cursor.fetchall()]
    
    for idx in indexes:
        try:
            cursor.execute(f"ALTER INDEX {SCHEMA}.{idx} UNUSABLE")
            print(f"  Disabled: {idx}")
        except Exception as e:
            print(f"  {idx}: {e}")
    
    cursor.close()
    conn.close()
    print(f"  Disabled {len(indexes)} indexes")
    return indexes

PARALLEL_DEGREE = 8  # Number of parallel processes for merge

def merge_staging_tables(main_table, staging_tables, drop_after=True):
    """Merge staging tables one by one with PARALLEL execution"""
    print(f"\nMerging {len(staging_tables)} staging tables into {main_table}...")
    print(f"Mode: PARALLEL {PARALLEL_DEGREE} (drop after each merge)\n")
    
    conn = get_connection()
    cursor = conn.cursor()
    
    # Enable parallel DML for this session
    cursor.execute("ALTER SESSION ENABLE PARALLEL DML")
    
    total_rows = 0
    merged_count = 0
    failed_tables = []
    
    for i, stg in enumerate(staging_tables, 1):
        try:
            # Merge with PARALLEL hint
            cursor.execute(f"""
                INSERT /*+ APPEND NOLOGGING PARALLEL({PARALLEL_DEGREE}) */ 
                INTO {SCHEMA}.{main_table}
                SELECT /*+ PARALLEL({PARALLEL_DEGREE}) */ * FROM {SCHEMA}.{stg}
            """)
            rows = cursor.rowcount
            conn.commit()
            
            total_rows += rows
            merged_count += 1
            
            # Drop immediately after merge
            if drop_after:
                try:
                    cursor.execute(f"DROP TABLE {SCHEMA}.{stg} PURGE")
                except:
                    pass
            
            # Progress every 10
            if i % 10 == 0 or i == len(staging_tables):
                print(f"  [{i:04d}/{len(staging_tables)}] Total: {total_rows:,} rows")
                
        except Exception as e:
            print(f"  ERROR {stg}: {e}")
            failed_tables.append(stg)
            conn.rollback()
    
    cursor.close()
    conn.close()
    
    print(f"\n{'='*60}")
    print(f"MERGE COMPLETE")
    print(f"{'='*60}")
    print(f"Tables merged: {merged_count}/{len(staging_tables)}")
    print(f"Total rows: {total_rows:,}")
    if failed_tables:
        print(f"Failed tables: {len(failed_tables)}")
        for t in failed_tables[:10]:
            print(f"  - {t}")
    print(f"{'='*60}")
    
    gc.collect()
    return total_rows

def main():
    print("="*60)
    print("MERGE STAGING TABLES")
    print("="*60)
    
    init_oracle_client()
    
    # Get table name
    table_name = input("\nEnter main table name: ").strip().upper()
    if not table_name:
        print("ERROR: Table name required!")
        return
    
    # Find staging tables
    print(f"\nSearching for staging tables matching {table_name}_STG*...")
    staging_tables = find_staging_tables(table_name)
    
    if not staging_tables:
        print("No staging tables found!")
        return
    
    print(f"\nFound {len(staging_tables)} staging tables:")
    for t in staging_tables[:10]:
        print(f"  - {t}")
    if len(staging_tables) > 10:
        print(f"  ... and {len(staging_tables) - 10} more")
    
    # Confirm
    drop_after = input("\nDrop staging tables after merge? (y/n): ").strip().lower() == 'y'
    disable_idx = input("Disable indexes before merge (FASTER)? (y/n): ").strip().lower() == 'y'
    confirm = input(f"\nMerge {len(staging_tables)} tables into {table_name}? (y/n): ").strip().lower()
    
    if confirm != 'y':
        print("Cancelled.")
        return
    
    start_time = datetime.now()
    
    # Disable indexes for faster merge
    if disable_idx:
        disable_indexes(table_name)
    
    # Merge
    merge_staging_tables(table_name, staging_tables, drop_after)
    
    elapsed = (datetime.now() - start_time).total_seconds()
    print(f"\nTotal time: {elapsed:.1f}s ({elapsed/60:.1f} minutes)")
    print("\nIMPORTANT: Run rebuild_indexes.py to rebuild indexes!")

if __name__ == "__main__":
    main()
